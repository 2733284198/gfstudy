# GoFrame路由注册

## 一、路由规则

`gf`框架自建了非常强大的路由功能，提供了比任何同类框架更加出色的路由特性，支持流行的命名匹配规则、模糊匹配规则及字段匹配规则，并提供了优秀的优先级管理机制。

```go
package main

import (
	"github.com/gogf/gf/frame/g"
	"github.com/gogf/gf/net/ghttp"
)

func main() {
	s := g.Server()
	s.BindHandler("/:name", func(r *ghttp.Request) {
		// 获取URL name参数
		r.Response.Writeln("name:" + r.GetString("name"))
		r.Response.Writeln("url" + r.Router.Uri)
	})
	s.BindHandler("/:name/update", func(r *ghttp.Request) {
		r.Response.Writeln("name:" + r.GetString("name"))
		r.Response.Writeln("url" +r.Router.Uri)
	})
	s.BindHandler("/:name/:action", func(r *ghttp.Request) {
		r.Response.Writeln("name:" + r.GetString("name"))
		r.Response.Writeln("action:" + r.GetString("action"))
		r.Response.Writeln("url" +r.Router.Uri)
	})
	s.BindHandler("/user/list/{field}.html", func(r *ghttp.Request) {
		// 获取URL field属性
		r.Response.Writeln("field:" + r.GetString("field"))
		r.Response.Writeln("url" +r.Router.Uri)
	})
	s.SetPort(8199)
	s.Run()
}
```

访问结果：

```go
POST http://localhost:8199/hello

hello
/:name

###
GET http://localhost:8199/abc

abc
/:name

###
GET http://localhost:8199/a/add

name:a
action:add
/:name/:action

###
GET http://localhost:8199/a/update

name:a
/:name/update

###
GET http://localhost:8199/user/list/11.html

field:11
/user/list/{field}.html
```

该方法是路由注册的最基础方法，其中的`pattern`为路由注册规则字符串，在其他路由注册方法中也会使用到，参数格式如下：

```undefined
[HTTPMethod:]路由规则[@域名]
```

其中`HTTPMethod`（支持的Method：`GET,PUT,POST,DELETE,PATCH,HEAD,CONNECT,OPTIONS,TRACE`）和`@域名`为非必需参数，一般来说直接给定路由规则参数即可，`BindHandler`会自动绑定**所有的**请求方式，如果给定`HTTPMethod`，那么路由规则仅会在该请求方式下有效。`@域名`可以指定生效的域名名称，那么该路由规则仅会在该域名下生效。

> `BindHandler`是最原生的路由注册方法，在大部分场景中，我们通常使用 **分组路由** 方式来管理路由



## 二、回调函数注册

回调函数注册方式是最简单且最灵活的的路由注册方式，注册的服务可以是一个实例化对象的方法地址，也可以是一个包方法地址。服务需要的数据可以通过`模块内部变量形式`或者`对象内部变量形式`进行管理，开发者可根据实际情况进行灵活控制。

我们可以直接通过`BindHandler`方法完成回调函数的注册，在框架的开发手册中很多地方都使用了回调函数注册的方式来做演示，因为这种注册方式比较简单。

### 示例1，包方法注册

```go
package main

import (
    "github.com/gogf/gf/container/gtype"
    "github.com/gogf/gf/frame/g"
    "github.com/gogf/gf/net/ghttp"
)

var (
    total = gtype.NewInt()
)

func Total(r *ghttp.Request) {
    r.Response.Write("total:", total.Add(1))
}

func main() {
    s := g.Server()
    s.BindHandler("/total", Total)
    s.SetPort(8199)
    s.Run()
}
```

在该示例中，我们通过包方法的形式来注册路由。该方法返回总共访问的次数，由于涉及到并发安全，因此`total`变量使用了`gtype.Int`并发安全类型。执行后，当我们不停访问 http://127.0.0.1:8199/total 时，可以看到返回的数值不停递增。

### 示例2，对象方法注册

```go
package main

import (
    "github.com/gogf/gf/container/gtype"
    "github.com/gogf/gf/frame/g"
    "github.com/gogf/gf/net/ghttp"
)

type Controller struct {
    total *gtype.Int
}

func (c *Controller) Total(r *ghttp.Request) {
    r.Response.Write("total:", c.total.Add(1))
}

func main() {
    s := g.Server()
    c := &Controller{
        total: gtype.NewInt(),
    }
    s.BindHandler("/total", c.Total)
    s.SetPort(8199)
    s.Run()
}
```

该示例与示例1的实现的效果一致，但我们使用了对象来封装业务逻辑所需的变量，使用回调函数注册来灵活注册对应的对象方法。

## 三、执行对象注册

执行对象注册是在注册时便给定一个实例化的对象，以后每一个请求都交给该对象（同一对象）处理，**该对象常驻内存不释放**。服务端进程在启动时便需要初始化这些执行对象，并且这些对象需要自行负责对自身数据的并发安全维护（往往对象的成员变量应当是并发安全的，每个请求执行完毕后该对象不会销毁，其成员变量也不会释放）。

### 执行对象注册

我们可以通过`BindObject`方法完成执行对象的注册。

```go
package main

import (
    "github.com/gogf/gf/frame/g"
    "github.com/gogf/gf/net/ghttp"
)

type Controller struct{}

func (c *Controller) Index(r *ghttp.Request) {
    r.Response.Write("index")
}

func (c *Controller) Show(r *ghttp.Request) {
    r.Response.Write("show")
}

func main() {
    s := g.Server()
    c := new(Controller)
    s.BindObject("/object", c)
    s.SetPort(8199)
    s.Run()
}
```

可以看到，执行对象在进行路由注册时便生成了一个对象(执行对象在`Server`启动时便生成)，此后不管多少请求进入，`Server`都是将请求转交给该对象对应的方法进行处理。需要注意的是，公开方法的定义，必须为以下形式：

```go
func(r *ghttp.Request) 
```

## 四、请求和响应对象

### 请求Request

请求输入依靠 `ghttp.Request` 对象实现，`ghttp.Request`继承了底层的`http.Request`对象。`ghttp.Request`包含一个与当前请求对应的返回输出对象`Response`，用于数据的返回处理。

可以看到`Request`对象的参数获取方法非常丰富，可以分为以下几类：

1. `Get*`: 常用方法，简化参数获取，`GetRequest*`的别名。
2. `GetQuery*`: 获取`GET`方式传递过来的参数，包括`Query String`及`Body`参数解析。
3. `GetForm*`: 获取表单方式传递过来的参数，表单方式提交的参数`Content-Type`往往为`application/x-www-form-urlencoded`, `application/form-data`, `multipart/form-data`, `multipart/mixed`等等。
4. `GetRequest*`: 获取客户端提交的参数，不区分提交方式。
5. `Get*Struct`: 将指定类型的请求参数绑定到指定的`struct`对象上，注意给定的参数为对象指针。绝大部分场景中往往使用`Parse`方法将请求数据转换为请求对象，具体详见后续章节。
6. `GetBody/GetBodyString`: 获取客户端提交的原始数据，该数据是客户端写入到`body`中的原始数据，与`HTTP Method`无关，例如客户端提交`JSON/XML`数据格式时可以通过该方法获取原始的提交数据。
7. `GetJson`: 自动将原始请求信息解析为`gjson.Json`对象指针返回。
8. `Exit*`: 用于请求流程退出控制；

### 响应Response

`ghttp.Response`对象实现了标准库的`http.ResponseWriter`接口。数据输出使用`Write*`相关方法实现，并且数据输出采用了`Buffer`机制，因此数据的处理效率比较高。任何时候可以通过`OutputBuffer`方法输出缓冲区数据到客户端，并清空缓冲区数据。

接口文档：https://godoc.org/github.com/gogf/gf/net/ghttp#Response

简要说明:

1. `Write*`方法用于数据的输出，可为任意的数据格式，内部通过断言对参数做自动分析。
2. `Write*Exit`方法用于数据输出后退出当前服务方法，可用于替代`return`返回方法。
3. `WriteJson*`/`WriteXml`方法用于特定数据格式的输出，这是为开发者提供的简便方法。
4. `WriteTpl*`方法用于模板输出，解析并输出模板文件，也可以直接解析并输出给定的模板内容。
5. `ParseTpl*`方法用于模板解析，解析模板文件或者模板内容，返回解析后的内容。

### 示例

```go
package main

import (
    "github.com/gogf/gf/frame/g"
    "github.com/gogf/gf/net/ghttp"
)

func main() {
    s := g.Server()
    s.BindHandler("/", func(r *ghttp.Request) {
        r.Response.Writeln(r.Get("amount"))
        r.Response.Writeln(r.GetInt("amount"))
        r.Response.Writeln(r.GetFloat32("amount"))
    })
    s.SetPort(8199)
    s.Run()
}
```

