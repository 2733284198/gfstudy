# Goframe数据库操作

## 基本介绍

`gf`框架的`ORM`功能由`gdb`模块实现，用于常用关系型数据库的`ORM`操作。其最大的特色在于同时支持`map`和`struct`两种方式操作数据库。`gdb`默认情况下使用的是`map`数据类型作为基础的数据表记录载体，开发者无需预先定义数据表记录`struct`便可直接对数据表记录执行各种操作。这样的设计赋予了开发者更高的灵活度和简便性。

> `gdb`数据库引擎底层采用了**链接池设计**，当链接不再使用时会自动关闭，因此链接对象不用的时候不需要显式使用`Close`方法关闭数据库连接。这也是`gdb`数据库模块人性化设计的地方，方便开发者使用数据库而无需手动维护大量的数据库链接对象。

**注意：为提高数据库操作安全性，在`ORM`操作中不建议直接将参数拼接成`SQL`字符串执行，建议尽量使用预处理的方式（充分使用`?`占位符）来传递SQL参数。`gdb`的底层实现中均采用的是预处理的方式处理开发者传递的参数，以充分保证数据库操作安全性。**

## 支持的数据库类型

Mysql，SQLite，PostgreSQL，SQLServer，Oracle

## 配置文件

> 推荐使用配置文件及单例对象来管理和使用数据库操作。

如果我们使用`g`对象管理模块中的`g.DB("数据库分组名称")`方法获取数据库操作对象，数据库对象将会自动读取`config.toml`配置文件中的相应配置项（通过配置管理模块），并自动初始化该数据库操作的单例对象。

数据库配置管理功能使用的是配置管理模块实现，因此同样支持多种数据格式如：`toml`, `yaml`, `json`, `xml`。默认并且推荐的配置文件数据格式为`toml`。

为兼容不同的数据库类型，`gdb`将数据库的各个字段拆分出来单独配置，这样对于各种数据库的对接来说兼容性会很好。但是对于开发者来说看起来配置比较多。针对于项目中使用的已确定的数据库类型的配置，我们可以使用`linkinfo`属性（名称也可以简化为`link`）进行配置。如：

```toml
[database]
    [[database.default]]
        link = "mysql:root:12345678@tcp(127.0.0.1:3306)/test"
    [[database.user]]
        link = "mysql:root:12345678@tcp(127.0.0.1:3306)/user"
```

注意每一项分组配置均可以是多个节点，支持负载均衡权重策略。如果不使用多节点负载均衡特性，仅使用配置分组特性，也可以简化为如下格式：

```toml
[database]
    [database.default]
        link = "mysql:root:12345678@tcp(127.0.0.1:3306)/test"
    [database.user]
        link = "mysql:root:12345678@tcp(127.0.0.1:3306)/user"
```

如果仅仅是单数据库节点，不使用配置分组特性，那么也可以简化为如下格式：

```toml
[database]
    link = "mysql:root:12345678@tcp(127.0.0.1:3306)/test"
```

不同数据类型对应的`linkinfo`如下:

| 数据库类型 | Linkinfo配置                                                 | 更多参数                                               |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------- |
| mysql      | `mysql: 账号:密码@tcp(地址:端口)/数据库名称`                 | [mysql](https://github.com/go-sql-driver/mysql)        |
| pgsql      | `pgsql: user=账号 password=密码 host=地址 port=端口 dbname=数据库名称` | [pq](https://github.com/lib/pq)                        |
| mssql      | `mssql: user id=账号;password=密码;server=地址;port=端口;database=数据库名称;encrypt=disable` | [go-mssqldb](https://github.com/denisenkom/go-mssqldb) |
| sqlite     | `sqlite: 文件绝对路径` (如: `/var/lib/db.sqlite3`)           | [go-sqlite3](https://github.com/mattn/go-sqlite3)      |
| oracle     | `oracle: 账号/密码@地址:端口/数据库名称`                     | [go-oci8](https://github.com/mattn/go-oci8)            |

## 日志输出配置

`gdb`支持日志输出，内部使用的是`glog.Logger`对象实现日志管理，并且可以通过配置文件对日志对象进行配置。默认情况下`gdb`关闭了`DEBUG`日志输出，如果需要打开`DEBUG`信息需要将数据库的`debug`参数设置为`true`。以下是为一个配置文件示例：

```toml
[database]
    [database.logger]
        Path   = "/var/log/gf-app/sql"
        Level  = "all"
        Stdout = true
    [database.primary]
        link   = "mysql:root:12345678@tcp(127.0.0.1:3306)/user_center"
        debug  = true
```

其中`database.logger`即为`gdb`的日志配置，当该配置不存在时，将会使用日志组件的默认配置

## 数据结构

为便于数据表记录的操作，ORM定义了5种基本的数据类型：

copy

```go
type Map         map[string]interface{} // 数据记录
type List        []Map                  // 数据记录列表

type Value       *gvar.Var              // 返回数据表记录值
type Record      map[string]Value       // 返回数据表记录键值对
type Result      []Record               // 返回数据表记录列表
```

1. `Map`与`List`用于ORM操作过程中的输入参数类型（与全局类型`g.Map`和`g.List`一致，在项目开发中常用`g.Map`和`g.List`替换）；
2. `Value/Record/Result`用于ORM操作的结果数据类型；

# 数据写入/保存

## `Insert/Replace/Save`

这三个链式操作方法用于数据的写入，并且支持自动的单条或者批量的数据写入，三者区别如下：

1. `Insert`

   使用`INSERT INTO`语句进行数据库写入，如果写入的数据中存在主键或者唯一索引时，返回失败，否则写入一条新数据；

2. `Replace`

   使用`REPLACE INTO`语句进行数据库写入，如果写入的数据中存在主键或者唯一索引时，会删除原有的记录，必定会写入一条新记录；

3. `Save`

   使用`INSERT INTO`语句进行数据库写入，如果写入的数据中存在主键或者唯一索引时，更新原有数据，否则写入一条新数据；

> 在部分数据库类型中，并不支持`Replace/Save`方法，具体请参考数据库类型介绍章节。

这三个方法往往需要结合`Data`方法使用，该方法用于传递数据参数，用于数据写入/更新等写操作，支持的参数为`string/map/slice/struct/*struct`。例如，在进行`Insert`操作时，开发者可以传递任意的`map`类型，如: `map[string]string`/`map[string]interface{}`/`map[interface{}]interface{}`等等，也可以传递任意的`struct/*struct/[]struct/[]*struct`类型。此外，这三个方法也支持直接的`data`参数输入，该参数`Data`方法参数一致。

## 示例1，基本使用

数据写入/保存方法往往需要结合`Data`方法使用：

```go
// INSERT INTO `user`(`name`) VALUES('john')
r, err := db.Table("user").Data(g.Map{"name": "john"}).Insert()
// REPLACE INTO `user`(`uid`,`name`) VALUES(10000,'john')
r, err := db.Table("user").Data(g.Map{"uid": 10000, "name": "john"}).Replace()
// INSERT INTO `user`(`uid`,`name`) VALUES(10001,'john') ON DUPLICATE KEY UPDATE `uid`=VALUES(`uid`),`name`=VALUES(`name`)
r, err := db.Table("user").Data(g.Map{"uid": 10001, "name": "john"}).Save()
```

也可以不使用`Data`方法，而给写入/保存方法直接传递数据参数：

```go
r, err := db.Table("user").Insert(g.Map{"name": "john"})
r, err := db.Table("user").Replace(g.Map{"uid": 10000, "name": "john"})
r, err := db.Table("user").Save(g.Map{"uid": 10001, "name": "john"})
```

数据参数也常用`struct`类型，例如当表字段为`uid/name/site`时：

```go
type User struct {
    Uid  int    `orm:"uid"`
    Name string `orm:"name"`
    Site string `orm:"site"`
}
user := &User{
    Uid:  1,
    Name: "john",
    Site: "https://goframe.org",
}
// INSERT INTO `user`(`uid`,`name`,`site`) VALUES(1,'john','https://goframe.org')
r, err := g.DB().Table("user").Data(user).Insert()
```

## 示例2，数据批量写入

```go
// INSERT INTO `user`(`name`) VALUES('john_1'),('john_2'),('john_3')
r, err := db.Table("user").Data(g.List{
    {"name": "john_1"},
    {"name": "john_2"},
    {"name": "john_3"},
}).Insert()
```

可以通过`Batch`方法指定批量操作中分批写入条数数量（默认是`10`），以下示例将会被拆分为两条写入请求：

```go
// INSERT INTO `user`(`name`) VALUES('john_1'),('john_2')
// INSERT INTO `user`(`name`) VALUES('john_3')
r, err := db.Table("user").Data(g.List{
    {"name": "john_1"},
    {"name": "john_2"},
    {"name": "john_3"},
}).Batch(2).Insert()
```

## 示例3，数据批量保存

批量保存操作与单条保存操作原理是一样的，当写入的数据中存在主键或者唯一索引时将会更新原有记录值，否则新写入一条记录。

```go
// INSERT INTO `user`(`uid`,`name`) VALUES(10000,'john_1'),(10001,'john_2'),(10002,'john_3') 
// ON DUPLICATE KEY UPDATE `uid`=VALUES(`uid`),`name`=VALUES(`name`)
r, err := db.Table("user").Data(g.List{
    {"uid":10000, "name": "john_1"},
    {"uid":10001, "name": "john_2"},
    {"uid":10002, "name": "john_3"},
}).Save()
```

# 数据更新/删除

## `Update`更新方法

`Update`用于数据的更新，往往需要结合`Data`及`Where`方法共同使用。`Data`方法用于指定需要更新的数据，`Where`方法用于指定更新的条件范围。同时，`Update`方法也支持直接给定数据和条件参数。

> 需要注意部分数据库类型支持更新条件结合查询、排序、分组、条数等共同使用。

使用示例：

```go
// UPDATE `user` SET `name`='john guo' WHERE name='john'
r, err := db.Table("user").Data(g.Map{"name" : "john guo"}).Where("name=?", "john").Update()
r, err := db.Table("user").Data("name='john guo'").Where("name=?", "john").Update()
// UPDATE `user` SET `status`=1 ORDER BY `login_time` asc LIMIT 10
r, err := db.Table("user").Data("status", 1).Order("login_time asc").Limit(10).Update()

// UPDATE `user` SET `status`=1
r, err := db.Table("user").Data("status=1").Update()
r, err := db.Table("user").Data("status", 1).Update()
r, err := db.Table("user").Data(g.Map{"status" : 1}).Update()
```

也可以直接给`Update`方法传递`data`及`where`参数：

```go
// UPDATE `user` SET `name`='john guo' WHERE name='john'
r, err := db.Table("user").Update(g.Map{"name" : "john guo"}, "name", "john")
r, err := db.Table("user").Update("name='john guo'", "name", "john")

// UPDATE `user` SET `status`=1
r, err := db.Table("user").Update("status=1")
r, err := db.Table("user").Update(g.Map{"status" : 1})
```

## `Delete`删除方法

`Delete`方法用于数据的删除。

使用示例

```go
// DELETE FROM `user` WHERE uid=10
r, err := db.Table("user").Where("uid", 10).Delete()
// DELETE FROM `user` ORDER BY `login_time` asc LIMIT 10
r, err := db.Table("user").Order("login_time asc").Limit(10).Delete()
```

也可以直接给`Delete`方法传递`where`参数：

```go
// DELETE FROM `user` WHERE `uid`=10
r, err := db.Table("user").Delete("uid", 10)
// DELETE FROM `user` WHERE `score`<60
r, err := db.Table("user").Delete("score < ", 60)
```

# 数据查询

## `Where/And/Or`查询条件

这三个方法用于传递查询条件参数，支持的参数为任意的`string/map/slice/struct/*struct`类型。

`Where`条件参数推荐使用字符串的参数传递方式（并使用`?`占位符预处理），因为`map`/`struct`类型作为查询参数无法保证顺序性，且在部分情况下（数据库有时会帮助你自动进行查询索引优化），数据库的索引和你传递的查询条件顺序有一定关系。

当使用多个`Where`方法连接查询条件时，作用同`And`。 此外，当存在多个查询条件时，`gdb`会默认将多个条件分别使用`()`符号进行包含，这种设计可以非常友好地支持查询条件分组。

使用示例：

copy

```go
// WHERE `uid`=1
Where("uid=1")
Where("uid", 1)
Where("uid=?", 1)
Where(g.Map("uid" : 1))
// WHERE `uid` <= 1000 AND `age` >= 18
Where(g.Map(
    "uid <=" : 1000,
    "age >=" : 18,
))
// WHERE (`uid` <= 1000) AND (`age` >= 18)
Where("uid <=?", 1000).Where("age >=?", 18)
Where("uid <=?", 1000).And("age >=?", 18)
// WHERE `level`=1 OR `money`>=1000000
Where("level=? OR money >=?", 1, 1000000)
// WHERE (`level`=1) OR (`money`>=1000000)
Where("level", 1).Or("money >=", 1000000)
// WHERE `uid` IN(1,2,3)
Where("uid IN(?)", g.Slice{1,2,3})
```

使用`struct`参数的示例，其中`orm`的`tag`用于指定`struct`属性与表字段的映射关系：

copy

```go
type Condition struct{
    Sex int `orm:"sex"`
    Age int `orm:"age"`
}
Where(Condition{1, 18})
// WHERE `sex`=1 AND `age`=18
```

## `WherePri`支持主键的查询条件

`WherePri`方法的功能同`Where`，但提供了对表主键的智能识别，常用于根据主键的便捷数据查询。假如`user`表的主键为`uid`，我们来看一下`Where`与`WherePri`的区别：

copy

```go
// WHERE `uid`=1
Table("user").Where("uid", 1)
Table("user").WherePri(1)
// WHERE `uid` IN(1,2,3)
Table("user").Where("uid", g.Slice{1,2,3})
Table("user").WherePri(g.Slice{1,2,3})
```

可以看到，当使用`WherePri`方法且给定参数为单一的参数基本类型或者`slice`类型时，将会被识别为主键的查询条件值。

## `All/One/Value/Count`数据查询

这四个方法是数据查询比较常用的方法：

1. `All` 用于查询并返回多条记录的列表/数组。
2. `One` 用于查询并返回单条记录。
3. `Value` 用于查询并返回一个字段值，往往需要结合`Fields`方法使用。
4. `Count` 用于查询并返回记录数。

此外，也可以看得到这四个方法定义中也支持条件参数的直接输入，参数类型与`Where`方法一致。但需要注意，其中`Value`方法的参数中至少应该输入字段参数。例如：

copy

```go
// SELECT `name` FROM `user` WHERE `uid`=1
Table("user").Value("name", "uid=1")
Table("user").Value("name", "uid"， 1)
// SELECT `name` FROM `user` WHERE `uid` IN(1,2,3)
Table("user").Value("name", "uid", g.Slice{1,2,3})
```

## `Struct/Structs/Scan`数据查询

这三个方法用于便捷地将查询的结果转换为`struct/*struct`或者`[]struct/[]*struct`数据。

1. ```
   Struct
   ```

   : 将查询结果转换为一个

   ```
   struct
   ```

   对象，查询结果应当是特定的一条记录，并且

   ```
   pointer
   ```

   参数应当为

   ```
   struct
   ```

   对象的指针地址（

   ```
   *struct
   ```

   或者

   ```
   **struct
   ```

   ），使用方式例如：

   copy

   ```go
    type User struct {
        Id         int
        Passport   string
        Password   string
        NickName   string
        CreateTime gtime.Time
    }
    user := new(User)
    err  := db.Table("user").Where("id", 1).Struct(user)
   ```

   或者

   copy

   ```go
    user ：= &User{}
    err  := db.Table("user").Where("id", 1).Struct(user)
   ```

   前两种方式都是预先初始化对象（提前分配内存），推荐的方式：

   copy

   ```go
    user := (*User)(nil)
    err  := db.Table("user").Where("id", 1).Struct(&user)
   ```

   这种方式只有在查询到数据的时候才会执行初始化及内存分配。注意在用法上的区别，特别是传递参数类型的差别（前两种方式传递的参数类型是

   ```
   *User
   ```

   ，这里传递的参数类型其实是

   ```
   **User
   ```

   ）。

2. ```
   Structs
   ```

   : 将多条查询结果集转换为一个

   ```
   []struct/[]*struct
   ```

   数组，查询结果应当是多条记录组成的结果集，并且

   ```
   pointer
   ```

   应当为数组的指针地址，使用方式例如：

   copy

   ```go
    users := ([]User)(nil)
    // 或者 var users []User
    err := db.Table("user").Structs(&users)
   ```

   或者

   copy

   ```go
    users := ([]*User)(nil)
    // 或者 var user []*User
    err := db.Table("user").Structs(&users)
   ```

3. `Scan`: 该方法会根据输入参数`pointer`的类型选择调用`Struct`还是`Structs`方法。如果结果是特定的一条记录，那么调用`Struct`方法；如果结果是`slice`类型则调用`Structs`方法。

## `Find*`支持主键条件的数据查询

`Find*`方法包含：`FindAll/FindOne/FineValue/FindCount/FindScan`，这些方法与`All/One/Value/Count/Scan`方法的区别在于，当方法直接给定条件参数时，前者的效果与`WherePri`方法一致；而后者的效果与`Where`方法一致。也就是说`Find*`方法的条件参数支持智能主键识别特性。

## `LeftJoin/RightJoin/InnerJoin`关联查询

1. `LeftJoin` 左关联查询；
2. `RightJoin` 右关联查询；
3. `InnerJoin` 内关联查询；

使用示例：

copy

```go
// 查询符合条件的单条记录(第一条)
// SELECT u.*,ud.site FROM user u LEFT JOIN user_detail ud ON u.uid=ud.uid WHERE u.uid=1 LIMIT 1
r, err := db.Table("user u").LeftJoin("user_detail ud", "u.uid=ud.uid").Fields("u.*,ud.site").Where("u.uid", 1).One()

// 查询指定字段值
// SELECT ud.site FROM user u RIGHT JOIN user_detail ud ON u.uid=ud.uid WHERE u.uid=1 LIMIT 1
r, err := db.Table("user u").RightJoin("user_detail ud", "u.uid=ud.uid").Fields("ud.site").Where("u.uid", 1).Value()

// 分组及排序
// SELECT u.*,ud.site FROM user u INNER JOIN user_detail ud ON u.uid=ud.uid GROUP BY city ORDER BY register_time asc
r, err := db.Table("user u").InnerJoin("user_detail ud", "u.uid=ud.uid").Fields("u.*,ud.city").Group("city").Order("register_time asc").All()

// 不使用join的联表查询
// SELECT u.*,ud.city FROM user u,user_detail ud WHERE u.uid=ud.uid
r, err := db.Table("user u,user_detail ud").Where("u.uid=ud.uid").Fields("u.*,ud.city").All()
```

## `Group/Order`分组与排序

`Group`方法用于查询分组，`Order`方法用于查询排序。使用示例：

```go
// SELECT COUNT(*) total,age FROM `user` GROUP BY age
r, err := db.Table("user").Fields("COUNT(*) total,age").Group("age").All()

// SELECT * FROM `student` ORDER BY class asc,course asc,score desc
r, err := db.Table("student").Order("class asc,course asc,score desc").All()
```

## `As`数据表别名

`As`方法用于指定模型别名。使用示例：

```go
user := db.Table("user").Safe()
// SELECT * FROM `user` AS u LEFT JOIN `user_detail` as ud ON(ud.id=u.id) WHERE u.id=1 LIMIT 1
r, err := user.As("u").LeftJoin("user_detail as ud", "ud.id=u.id").Where("u.id", 1).One()
```

## 示例1, 基本使用

`Where + string`，条件参数使用字符串和预处理。

```go
// 查询多条记录并使用Limit分页
// SELECT * FROM user WHERE uid>1 LIMIT 0,10
r, err := db.Table("user").Where("uid > ?", 1).Limit(0, 10).All()

// 使用Fields方法查询指定字段
// 未使用Fields方法指定查询字段时，默认查询为*
// SELECT uid,name FROM user WHERE uid>1 LIMIT 0,10
r, err := db.Table("user").Fileds("uid,name").Where("uid > ?", 1).Limit(0, 10).All()

// 支持多种Where条件参数类型
// SELECT * FROM user WHERE uid=1 LIMIT 1
r, err := db.Table("user").Where("u.uid=1",).One()
r, err := db.Table("user").Where("u.uid", 1).One()
r, err := db.Table("user").Where("u.uid=?", 1).One()
// SELECT * FROM user WHERE (uid=1) AND (name='john') LIMIT 1
r, err := db.Table("user").Where("uid", 1).Where("name", "john").One()
r, err := db.Table("user").Where("uid=?", 1).And("name=?", "john").One()
// SELECT * FROM user WHERE (uid=1) OR (name='john') LIMIT 1
r, err := db.Table("user").Where("uid=?", 1).Or("name=?", "john").One()
```

`Where + slice`，预处理参数可直接通过`slice`参数给定。

```go
// SELECT * FROM user WHERE age>18 AND name like '%john%'
r, err := db.Table("user").Where("age>? AND name like ?", g.Slice{18, "%john%"}).All()
// SELECT * FROM user WHERE status=1
r, err := db.Table("user").Where("status=?", g.Slice{1}).All()
```

`Where + map`，条件参数使用任意`map`类型传递。

```go
// SELECT * FROM user WHERE uid=1 AND name='john' LIMIT 1
r, err := db.Table("user").Where(g.Map{"uid" : 1, "name" : "john"}).One()
// SELECT * FROM user WHERE uid=1 AND age>18 LIMIT 1
r, err := db.Table("user").Where(g.Map{"uid" : 1, "age>" : 18}).One()
```

`Where + struct/*struct`，`struct`标签支持 `orm/json`，映射属性到字段名称关系。

```go
type User struct {
    Id       int    `json:"uid"`
    UserName string `orm:"name"`
}
// SELECT * FROM user WHERE uid =1 AND name='john' LIMIT 1
r, err := db.Table("user").Where(User{ Id : 1, UserName : "john"}).One()
// SELECT * FROM user WHERE uid =1 LIMIT 1
r, err := db.Table("user").Where(&User{ Id : 1}).One()
```

以上的查询条件相对比较简单，我们来看一个比较复杂的查询示例。

```go
condition := g.Map{
    "title like ?"         : "%九寨%",
    "online"               : 1,
    "hits between ? and ?" : g.Slice{1, 10},
    "exp > 0"              : nil,
    "category"             : g.Slice{100, 200},
}
result, err := db.Table("article").Where(condition).All()
// SELECT * FROM article WHERE title like '%九寨%' AND online=1 AND hits between 1 and 10 AND exp > 0 AND category IN(100,200)
```

## 示例2, `select in`查询

使用字符串、`slice`参数类型。当使用`slice`参数类型时，预处理占位符只需要一个`?`即可。

```go
// SELECT * FROM user WHERE uid IN(100,10000,90000)
r, err := db.Table("user").Where("uid IN(?,?,?)", 100, 10000, 90000).All()
// SELECT * FROM user WHERE gender=1 AND uid IN(100,10000,90000)
r, err := db.Table("user").Where("gender=? AND uid IN(?)", 1, g.Slice{100, 10000, 90000}).All()
// SELECT COUNT(*) FROM user WHERE age in(18,50)
r, err := db.Table("user").Where("age IN(?,?)", 18, 50).Count()
```

使用任意`map`参数类型。

```go
// SELECT * FROM user WHERE gender=1 AND uid IN(100,10000,90000)
r, err := db.Table("user").Where(g.Map{
    "gender" : 1,
    "uid"    : g.Slice{100,10000,90000},
}).All()
```

使用`struct`参数类型，注意查询条件的顺序和`struct`的属性定义顺序有关。

```go
type User struct {
    Id     []int  `orm:"uid"`
    Gender int    `orm:"gender"`
}
// SELECT * FROM user WHERE uid IN(100,10000,90000) AND gender=1
r, err := db.Table("user").Where(User{
    "gender" : 1,
    "uid"    : []int{100, 10000, 90000},
}).All()
```

## 示例3, `like`查询

```go
// SELECT * FROM user WHERE name like '%john%'
r, err := db.Table("user").Where("name like ?", "%john%").All()
// SELECT * FROM user WHERE birthday like '1990-%'
r, err := db.Table("user").Where("birthday like ?", "1990-%").All()
```

## 示例4, `sum`查询

```go
// SELECT SUM(score) FROM user WHERE uid=1
r, err := db.Table("user").Fields("SUM(score)").Where("uid=?", 1).Value()
```

## 示例5, `count`查询

```go
// SELECT COUNT(1) FROM user WHERE `birthday`='1990-10-01'
r, err := db.Table("user").Where("birthday=?", "1990-10-01").Count()
// SELECT COUNT(uid) FROM user WHERE `birthday`='1990-10-01'
r, err := db.Table("user").Fields("uid").Where("birthday=?", "1990-10-01").Count()
```

## 示例6, `distinct`查询

```go
// SELECT DISTINCT uid,name FROM user 
r, err := db.Table("user").Fields("DISTINCT uid,name").All()
```

# 数据结构

查询结果的数据结构如下：

copy

```go
type Value  = *gvar.Var              // 返回数据表记录值
type Record   map[string]Value       // 返回数据表记录键值对
type Result   []Record               // 返回数据表记录列表
```

1. `Value/Record/Result`用于ORM操作的结果数据类型。
2. `Result`表示数据表记录列表，`Record`表示一条数据表记录，`Value`表示记录中的一条键值数据。
3. `Value`是`*gvar.Var`类型的别名类型，方便于后续的数据类型转换。

# Record记录处理

接口文档： https://godoc.org/github.com/gogf/gf/database/gdb

```go
// 数据表记录
type Record
    func (r Record) GMap() *gmap.StrAnyMap
    func (r Record) IsEmpty() bool
    func (r Record) Map() Map
    func (r Record) Xml(rootTag ...string) string
    func (r Record) Json() string
    func (r Record) Struct(pointer interface{}) error
```

`gdb`为数据表记录操作提供了极高的灵活性和简便性，除了支持以`map`的形式访问/操作数据表记录以外，也支持将数据表记录转换为`struct`进行处理。我们以下使用一个简单的示例来演示该特性。

首先，我们的用户表结构是这样的（简单设计的示例表）：

```sql
CREATE TABLE `user` (
  `uid` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(30) NOT NULL DEFAULT '' COMMENT '昵称',
  `site` varchar(255) NOT NULL DEFAULT '' COMMENT '主页',
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

其次，我们的表数据如下：

```html
uid  name   site
1    john   https://goframe.org
```

最后，我们的示例程序如下：

```go
package main

import (
    "database/sql"
    "github.com/gogf/gf/frame/g"
)

type User struct {
    Uid  int
    Name string
}

func main() {
    var user *User
    err := g.DB().Table("user").Where("uid", 1).Scan(&user)
    if err != nil && err != sql.ErrNoRows {
        g.Log().Header(false).Fatal(err)
    }
    if user != nil {
        g.Log().Header(false).Println(user)
    }
}
```

执行后，输出结果为：

```json
{"Uid":1,"Name":"john"}
```

这里，我们自定义了一个`struct`，里面只包含了`Uid`和`Name`属性，可以看到它的属性并不和数据表的字段一致，这也是`ORM`灵活的特性之一：支持指定属性获取。

通过`gdb.Model.Scan`方法可以将查询到的数据记录转换为`struct`对象或者`struct`对象数组。由于这里传递的参数为`&user`即`**User`类型，那么将会转换为一个`struct`对象，如果传递为`[]*User`类型的参数，将会转换为数组结果，请查看后续示例。具体方法介绍请查看链式操作章节。

**属性字段映射规则：**

需要注意的是，`map`中的键名为`uid,name,site`，而`struct`中的属性为`Uid,Name`，那么他们之间是如何执行映射的呢？主要是以下几点简单的规则：

1. `struct`中需要匹配的属性必须为`公开属性`(首字母大写)；
2. 记录结果中键名会自动按照 **`不区分大小写`** 且 **忽略`-/_/空格`符号** 的形式与`struct`属性进行匹配；
3. 如果匹配成功，那么将键值赋值给属性，如果无法匹配，那么忽略该键值；

以下是几个匹配的示例：

```html
记录键名    struct属性     是否匹配
name       Name           match
Email      Email          match
nickname   NickName       match
NICKNAME   NickName       match
Nick-Name  NickName       match
nick_name  NickName       match
nick_name  Nick_Name      match
NickName   Nick_Name      match
Nick-Name  Nick_Name      match
```

> 由于数据库结果集转`struct`的底层是依靠`gconv.Struct`方法实现的，因此如果想要实现**自定义的属性转换**，以及更详细的映射规则说明，请参考【[gconv.Struct](javascript:loadMarkdown('/util/gconv/struct', true);)】章节。

# Result结果集处理

`Result/Record`数据类型根据数据结果集操作的需要，往往需要根据记录中**特定的字段**作为键名进行数据检索，因此它包含多个用于转换`Map/List`的方法，同时也包含了常用数据结构`JSON/XML`的转换方法。

接口文档： https://godoc.org/github.com/gogf/gf/database/gdb

```go
// 数据表记录列表
type Result
    func (r Result) IsEmpty() bool
    func (r Result) Json() string
    func (r Result) List() List
    func (r Result) MapKeyInt(key string) map[int]Map
    func (r Result) MapKeyStr(key string) map[string]Map
    func (r Result) MapKeyUint(key string) map[uint]Map
    func (r Result) RecordKeyInt(key string) map[int]Record
    func (r Result) RecordKeyStr(key string) map[string]Record
    func (r Result) RecordKeyUint(key string) map[uint]Record
    func (r Result) Structs(pointer interface{}) (err error)
    func (r Result) Xml(rootTag ...string) string
```

由于方法比较简单，这里便不再举例说明。需要注意的是两个方法`Record.Map`及`Result.List`，这两个方法也是使用比较频繁的方法，用以将`ORM`查询结果信息转换为可做展示的数据类型。由于结果集字段值底层为`[]byte`类型，虽然使用了新的`Value`类型做了封装，并且也提供了数十种常见的类型转换方法(具体请阅读【[gvar通用动态变量](javascript:loadMarkdown('/container/gvar/index', true);)】章节)，但是大多数时候需要直接将结果`Result`或者`Record`直接作为`json`或者`xml`数据结构返回，就需要做转换才行。

使用示例：

```go
package main

import (
    "database/sql"
    "github.com/gogf/gf/frame/g"
)

type User struct {
    Uid  int
    Name string
    Site string
}

func main() {
    var user []*User
    err := g.DB().Table("user").Where("uid", 1).Scan(&user)
    if err != nil && err != sql.ErrNoRows {
        g.Log().Header(false).Fatal(err)
    }
    if user != nil {
        g.Log().Header(false).Println(user)
    }
}
```

执行后，输出结果为：

```json
[{"Uid":1,"Name":"john","Site":"https://goframe.org"}]
```